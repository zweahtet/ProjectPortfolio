{"pageProps":{"courses":[{"_id":"6199dc85053409ee978cfaaa","category":"Tree Recursion","title":"Pascal's Triangle","question":"Every number in Pascal's triangle is defined as the sum of the item above it and the item above and to the left of it. Use 0 if the item does not exist.\n\nDefine the procedure pascal(row, column) which takes a row and a column, and finds the value of the item at that position in Pascal's triangle. Rows and columns are zero-indexed; that is, the first row is row 0 instead of 1 and the first column is column 0 instead of column 1.\n\nFor example, the item at row 2, column 1 in Pascal's triangle is 2.","code":"def pascal(row, column):\n    \"\"\"Returns the value of the item in Pascal's Triangle \n    whose position is specified by row and column.\n    >>> pascal(0, 0)\n    1\n    >>> pascal(0, 5)\t# Empty entry; outside of Pascal's Triangle\n    0\n    >>> pascal(3, 2)\t# Row 3 (1 3 3 1), Column 2\n    3\n    >>> pascal(4, 2)     # Row 4 (1 4 6 4 1), Column 2\n    6\n    \"\"\"\n    if column == 0:\n    \treturn 1\n    elif row == 0:\n    \treturn 0\n    else:\n    \treturn pascal(row - 1, column) + pascal(row - 1, column - 1)\n\n","course":"cs61a","url":"http://cs61a.org"},{"_id":"61aa7609d218089726fa40d8","category":"Linked List","title":"Sum Nums","question":"Write a function that takes in a linked list and returns the sum of all its elements. You may assume all elements in s are integers. Try to implement this recursively!","code":"def sum_nums(s):\n    \"\"\"\n    >>> a = Link(1, Link(6, Link(7)))\n    >>> sum_nums(a)\n    14\n    \"\"\"\n    if s == Link.empty:\n        return 0\n    return s.first + sum_nums(s.rest)","course":"cs61a","url":"http://cs61a.org"},{"_id":"61aa7697d218089726fa40d9","category":"Linked List","title":"Multiply Links","question":"Write a function that takes in a Python list of linked lists and multiplies them element-wise. It should return a new linked list.\n\nIf not all of the Link objects are of equal length, return a linked list whose length is that of the shortest linked list given. You may assume the Link objects are shallow linked lists, and that lst_of_lnks contains at least one linked list.","code":"def multiply_lnks(lst_of_lnks):\n    \"\"\"\n    >>> a = Link(2, Link(3, Link(5)))\n    >>> b = Link(6, Link(4, Link(2)))\n    >>> c = Link(4, Link(1, Link(0, Link(2))))\n    >>> p = multiply_lnks([a, b, c])\n    >>> p.first\n    48\n    >>> p.rest.first\n    12\n    >>> p.rest.rest.rest is Link.empty\n    True\n    \"\"\"\n    # Implementation Note: you might not need all lines in this skeleton code\n    product = 1\n    for lnk in lst_of_lnks:\n        if lnk is Link.empty:\n            return Link.empty\n        product *= lnk.first\n    lst_of_lnks_rests = [lnk.rest for lnk in lst_of_lnks]\n    return Link(product, multiply_lnks(lst_of_lnks_rests))","course":"cs61a","url":"http://cs61a.org"},{"_id":"61ac314a22a0f64d7cc39d75","category":"Recursion","title":"Paths List","question":"(Adapted from Fall 2013) Fill in the blanks in the implementation of paths, which takes as input two positive integers x and y. It returns a list of paths, where each path is a list containing steps to reach y from x by repeated incrementing or doubling. For instance, we can reach 9 from 3 by incrementing to 4, doubling to 8, then incrementing again to 9, so one path is [3, 4, 8, 9]","code":"def paths(x, y):\n    \"\"\"Return a list of ways to reach y from x by repeated\n    incrementing or doubling.\n    >>> paths(3, 5)\n    [[3, 4, 5]]\n    >>> sorted(paths(3, 6))\n    [[3, 4, 5, 6], [3, 6]]\n    >>> sorted(paths(3, 9))\n    [[3, 4, 5, 6, 7, 8, 9], [3, 4, 8, 9], [3, 6, 7, 8, 9]]\n    >>> paths(3, 3) # No calls is a valid path\n    [[3]]\n    \"\"\"\n    if x > y:\n        return []\n    elif x == y:\n        return [[x]]\n    else:\n        a = paths(x + 1, y)\n        b = paths(x * 2, y)\n        return [[x] + subpath for subpath in a + b]","course":"cs61a","url":"http://cs61a.org"},{"_id":"61ac31d022a0f64d7cc39d76","category":"Mutation","title":"Reverse","question":"Write a function that reverses the given list. Be sure to mutate the original list. This is practice, so don't use the built-in reverse function!","code":"def reverse(lst):\n    \"\"\"Reverses lst using mutation.\n\n    >>> original_list = [5, -1, 29, 0]\n    >>> reverse(original_list)\n    >>> original_list\n    [0, 29, -1, 5]\n    >>> odd_list = [42, 72, -8]\n    >>> reverse(odd_list)\n    >>> odd_list\n    [-8, 72, 42]\n    \"\"\"\n    # iterative solution\n    midpoint = len(lst) // 2\n    last = len(lst) - 1\n    for i in range(midpoint):\n        lst[i], lst[last - i] = lst[last - i], lst[i]","course":"cs61a","url":"http://cs61a.org"},{"_id":"61ac321e22a0f64d7cc39d77","category":"Trees","title":"Reverse Other","question":"Write a function reverse_other that mutates the tree such that labels on every other (odd-depth) level are reversed. For example, Tree(1,[Tree(2, [Tree(4)]), Tree(3)]) becomes Tree(1,[Tree(3, [Tree(4)]), Tree(2)]). Notice that the nodes themselves are not reversed; only the labels are.","code":"def reverse_other(t):\n    \"\"\"Mutates the tree such that nodes on every other (odd-depth)\n    level have the labels of their branches all reversed.\n\n    >>> t = Tree(1, [Tree(2), Tree(3), Tree(4)])\n    >>> reverse_other(t)\n    >>> t\n    Tree(1, [Tree(4), Tree(3), Tree(2)])\n    >>> t = Tree(1, [Tree(2, [Tree(3, [Tree(4), Tree(5)]), Tree(6, [Tree(7)])]), Tree(8)])\n    >>> reverse_other(t)\n    >>> t\n    Tree(1, [Tree(8, [Tree(3, [Tree(5), Tree(4)]), Tree(6, [Tree(7)])]), Tree(2)])\n    \"\"\"\n    def reverse_helper(t, need_reverse):\n        if t.is_leaf():\n            return\n        new_labs = [child.label for child in t.branches][::-1]\n        for i in range(len(t.branches)):\n            child = t.branches[i]\n            reverse_helper(child, not need_reverse)\n            if need_reverse:\n                child.label = new_labs[i]\n    reverse_helper(t, True)","course":"cs61a","url":"http://cs61a.org"},{"_id":"61ac327d22a0f64d7cc39d78","category":"Linked List","title":"Deep Map","question":"Implement deep_map, which takes a function f and a link. It returns a new linked list with the same structure as link, but with f applied to any element within link or any Link instance contained in link.\n\nThe deep_map function should recursively apply fn to each of that Link's elements rather than to that Link itself.\n\nHint: You may find the built-in isinstance function for checking if something is an instance of an object.","code":"def deep_map(f, link):\n    \"\"\"Return a Link with the same structure as link but with fn mapped over\n    its elements. If an element is an instance of a linked list, recursively\n    apply f inside that linked list as well.\n\n    >>> s = Link(1, Link(Link(2, Link(3)), Link(4)))\n    >>> print(deep_map(lambda x: x * x, s))\n    <1 <4 9> 16>\n    >>> print(s) # unchanged\n    <1 <2 3> 4>\n    >>> print(deep_map(lambda x: 2 * x, Link(s, Link(Link(Link(5))))))\n    <<2 <4 6> 8> <<10>>>\n    \"\"\"\n    if link is Link.empty:\n        return link\n    if isinstance(link.first, Link):\n        first = deep_map(f, link.first)\n    else:\n        first = f(link.first)\n    return Link(first, deep_map(f, link.rest))","course":"cs61a","url":"http://cs61a.org"},{"_id":"61ac337022a0f64d7cc39d79","category":"Generators","title":"Repeated","question":"Write a generator function that yields functions that are repeated applications of a one-argument function f. The first function yielded should apply f 0 times (the identity function), the second function yielded should apply f once, etc.","code":"def repeated(f):\n    \"\"\"\n    >>> double = lambda x: 2 * x\n    >>> funcs = repeated(double)\n    >>> identity = next(funcs)\n    >>> double = next(funcs)\n    >>> quad = next(funcs)\n    >>> oct = next(funcs)\n    >>> quad(1)\n    4\n    >>> oct(1)\n    8\n    >>> [g(1) for _, g in\n    ...  zip(range(5), repeated(lambda x: 2 * x))]\n    [1, 2, 4, 8, 16]\n    \"\"\"\n\n    g = lambda x : x\n    while True:\n        yield g\n        g = (lambda g: lambda x: f(g(x)))(g)","course":"cs61a","url":"http://cs61a.org"},{"_id":"61ac33c822a0f64d7cc39d7a","category":"Scheme","title":"Group By None Decreasing","question":"Define a function nondecreaselist, which takes in a scheme list of numbers and outputs a list of lists, which overall has the same numbers in the same order, but grouped into lists that are non-decreasing.\n\nFor example, if the input is a stream containing elements\n\n(1 2 3 4 1 2 3 4 1 1 1 2 1 1 0 4 3 2 1)\n\nthe output should contain elements\n\n((1 2 3 4) (1 2 3 4) (1 1 1 2) (1 1) (0 4) (3) (2) (1))\n\nNote:_ The skeleton code is just a suggestion; feel free to use your own structure if you prefer.","code":"(define (nondecreaselist s)\n\n    (if (null? s)\n        nil\n        (let ((rest (nondecreaselist (cdr s)) ))\n            (if (or (null? (cdr s)) (> (car s) (car (cdr s))))\n                (cons (list (car s)) rest)\n                (cons (cons (car s) (car rest)) (cdr rest))\n            )\n        )\n    )\n)\n\n(expect (nondecreaselist '(1 2 3 1 2 3)) ((1 2 3) (1 2 3)))\n\n(expect (nondecreaselist '(1 2 3 4 1 2 3 4 1 1 1 2 1 1 0 4 3 2 1))\n        ((1 2 3 4) (1 2 3 4) (1 1 1 2) (1 1) (0 4) (3) (2) (1)))","course":"cs61a","url":"http://cs61a.org"}]},"__N_SSG":true}